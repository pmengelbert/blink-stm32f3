/* Linker script for STM32F303 Cortex-M3 ARM MCU */

/* Define the memory mapping of the chip */
MEMORY
{
  flash  (rx) : ORIGIN = 0x08000000, LENGTH = 128K
  ram   (rwx) : ORIGIN = 0x20000000, LENGTH =  40K
  ccm   (rwx) : ORIGIN = 0x10000000, LENGTH =   8K
}

/* Define some useful symbols that can be used from the code */
__rom_start__	= ORIGIN(flash);
__rom_size__	= LENGTH(flash);
__ram_start__	= ORIGIN(ram);
__ram_size__	= LENGTH(ram);
__ram_end__	    = __ram_start__ + __ram_size__;
__ccm_start__	= ORIGIN(ccm);
__ccm_size__	= LENGTH(ccm);

/* These are used to setup the C heap and stack */
/* The stack is at the top of RAM and grows downwards, it takes half the memory */
__stack_end__	= __ram_end__;		/* Top of RAM */

/* The heap is the remaining space in RAM when all the statics and the stacks are allocated.
 * It only gets used if you use malloc()/free(), anyway. */
__heap_start__	= __bss_end__;		/* Between bss and stack */

/*
 *  The following symbols contain the various interrupt handler vectors. The STM32F303's
 *  ARM Cortex-M4 CPU, when operating in thumb mode (as the STM32 does), requires
 *  the ones bit for all vectors in this table to be set to one. It seems strange, because
 *  then the vector's address is an odd number, and one higher than the actual address of our
 *  handlers. But it is correct.
 */

NMI_Handler                     |= 1;
HardFault_Handler               |= 1;
MemManage_Handler               |= 1;
BusFault_Handler                |= 1;
UsageFault_Handler              |= 1;
SVC_Handler                     |= 1;
PendSV_Handler                  |= 1;
SysTick_Handler                 |= 1;
WWDG_IRQHandler                 |= 1;
PVD_IRQHandler                  |= 1;
TAMP_STAMP_IRQHandler           |= 1;
RTC_WKUP_IRQHandler             |= 1;
FLASH_IRQHandler                |= 1;
RCC_IRQHandler                  |= 1;
EXTI0_IRQHandler                |= 1;
EXTI1_IRQHandler                |= 1;
EXTI2_IRQHandler                |= 1;
EXTI3_IRQHandler                |= 1;
EXTI4_IRQHandler                |= 1;
DMA1_Stream0_IRQHandler         |= 1;
DMA1_Stream1_IRQHandler         |= 1;
DMA1_Stream2_IRQHandler         |= 1;
DMA1_Stream3_IRQHandler         |= 1;
DMA1_Stream4_IRQHandler         |= 1;
DMA1_Stream5_IRQHandler         |= 1;
DMA1_Stream6_IRQHandler         |= 1;
ADC_IRQHandler                  |= 1;
CAN1_TX_IRQHandler              |= 1;
CAN1_RX0_IRQHandler             |= 1;
CAN1_RX1_IRQHandler             |= 1;
CAN1_SCE_IRQHandler             |= 1;
EXTI9_5_IRQHandler              |= 1;
TIM1_BRK_TIM15_IRQHandler       |= 1;
TIM1_UP_TIM16_IRQHandler        |= 1;
TIM1_TRG_COM_TIM17_IRQHandler   |= 1;
TIM1_CC_IRQHandler              |= 1;
TIM2_IRQHandler                 |= 1;
TIM3_IRQHandler                 |= 1;
TIM4_IRQHandler                 |= 1;
I2C1_EV_IRQHandler              |= 1;
I2C1_ER_IRQHandler              |= 1;
I2C2_EV_IRQHandler              |= 1;
I2C2_ER_IRQHandler              |= 1;
SPI1_IRQHandler                 |= 1;
SPI2_IRQHandler                 |= 1;
USART1_IRQHandler               |= 1;
USART2_IRQHandler               |= 1;
USART3_IRQHandler               |= 1;
EXTI15_10_IRQHandler            |= 1;
RTC_Alarm_IRQHandler            |= 1;
OTG_FS_WKUP_IRQHandler          |= 1;
TIM8_BRK_IRQHandler             |= 1;
TIM8_UP_IRQHandler              |= 1;
TIM8_TRG_COM_IRQHandler         |= 1;
TIM8_CC_IRQHandler              |= 1;
ADC3_IRQHandler                 |= 1;
FMC_IRQHandler                  |= 1;
SPI3_IRQHandler                 |= 1;
UART4_IRQHandler                |= 1;
UART5_IRQHandler                |= 1;
TIM6_DAC_IRQHandler             |= 1;
TIM7_IRQHandler                 |= 1;
DMA2_Channel1_IRQHandler        |= 1;
DMA2_Channel2_IRQHandler        |= 1;
DMA2_Channel3_IRQHandler        |= 1;
DMA2_Channel4_IRQHandler        |= 1;
DMA2_Channel5_IRQHandler        |= 1;
ADC4_IRQHandler                 |= 1;
COMP_1_2_3_IRQHandler           |= 1;
COMP_4_5_6_IRQHandler           |= 1;
COMP_7_IRQHandler               |= 1;
I2C3_EV_IRQHandler              |= 1;
I2C3_ER_IRQHandler              |= 1;
USB_HP_IRQHandler               |= 1;
USB_LP_IRQHandler               |= 1;
USB_WKUP_RMP_IRQHandler         |= 1;
TIM20_BRK_IRQHandler            |= 1;
TIM20_UP_IRQHandler             |= 1;
TIM20_TRG_COM_IRQHandler        |= 1;
TIM20_CC_IRQHandler             |= 1;
FPU_IRQHandler                  |= 1;
SPI4_IRQHandler                 |= 1;

/* Now define the memory mapping. The section names in parentheses reflect the
 * sections generated by the compiler. The * means 'from all object files'. The
 * only case where you need to do otherwise is usually to setup the interrupt
 * vectors, if you need them at the start of flash or some other useful place.*/
SECTIONS
{
  . = 0;

	/* Here is the ROM */
  .text : {
  KEEP(*(.boot*))				/* Reset vectors */
  *(.text*)				/* Program code */
  *(.rodata*)			/* Read only data */
  *(.glue_7)
  *(.glue_7t)
  *(.eh_frame)
  . = ALIGN(4);
  __ctors_start__ = .;
  KEEP(*(.init_array));			/* C++ constructors */
  KEEP(*(.ctors));			/* C++ constructors */
  __ctors_end__ = .;
  . = ALIGN(16);
  __text_end__ = .;
  } >flash

  /* Initialized data is allocated in flash, but will be moved to RAM by the
   * boot code. */
  . = ALIGN(16);
  __load_data_beg__ = .; /* This is the address of the data section *before it has been moved by the linker* */
  .data : {
  __data_beg__ = .;
  *(.data)				/* Initialized data */
  __data_end__ = .;
  } >ram AT > flash 
  __load_data_end__ = .; /* Address of the end of the data section  *before the linker moves it* */
  __data_size__ = __data_end__ - __data_beg__;

  /* And here is all the uninitialized data. It will follow the initialized
   * part in RAM, and need not be copied from flash, only zero-cleared. */
  .bss (NOLOAD) : ALIGN(16) {
  __bss_beg__ = .;			/* Used in crt0.S */
  *(.bss)				/* Uninitialized data */
  *(COMMON)				/* Common data */
  __bss_end__ = .;			/* Used in crt0.S */
  } >ram
}  
